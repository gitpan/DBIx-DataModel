=head1 NAME

DBIx::DataModel::Doc::Reference - General reference for DBIx::DataModel

=head1 DOCUMENTATION CONTEXT

This chapter is part of the C<DBIx::DataModel> manual.

=over

=item * 

L<SYNOPSIS AND DESCRIPTION|DBIx::DataModel>

=item * 

L<DESIGN|DBIx::DataModel::Doc::Design>

=item * 

L<QUICKSTART|DBIx::DataModel::Doc::Quickstart>

=item *

REFERENCE

=item *

L<MISC|DBIx::DataModel::Doc::Misc>

=item *

L<INTERNALS|DBIx::DataModel::Doc::Internals>

=item *

L<GLOSSARY|DBIx::DataModel::Doc::Glossary>

=back


=head1 DESCRIPTION


B<WARNING> : Version 2 of C<DBIx::DataModel> is a major refactoring
from versions 1.*, with a number of incompatible changes in the API
(classes renamed, arguments renamed or reorganized, etc. -- see
L<DBIx::DataModel::Doc::Delta_2.0>). The documentation below has not
been fully updated yet to reflect these changes.

This chapter is the detailed description
of C<DBIx::DataModels> methods for creating and using
schemas. 

Automatic schema generation from external sources is not
covered here; see L<DBIx::DataModel::Schema::Generator>.

Detailed use of B<statements> is not covered here either,
because explicit programming of the various statement 
phases (sqlize, prepare, bind, execute, etc.) is 
seldom needed. If you want to finely tune these operations,
read the 
L<DESIGN|DBIx::DataModel::Doc::Design/"STATEMENT OBJECTS"> 
section of the manual (purpose, lifecycle, etc.), and
the L<DBIx::DataModel::Statement|DBIx::DataModel::Statement> page.



=head1 GENERAL CONVENTION

Methods listed below for declaring schema, tables, associations, etc.
come in two flavours :

=over

=item *

a "front-end" method, starting with an uppercase letter,
that uses positional parameters. This version is prefered
for conciseness and for backwards compatibility.

=item *

a "back-end" method, called C<define_schema>, C<define_table>, etc.,
that uses named parameters. This version is prefered for
completeness.

=back

The invocant for front-end methods can be either
the Schema class name, or the meta-schema instance.
The invocant for back-end methods must be 
the meta-schema instance.


=head1 META-SCHEMA DECLARATION

=head2 Schema() / define_schema()

  # front-end method
  my $schema_class = DBIx::DataModel->Schema($schema_name, %options);
  
  # or (back-end method)
  my $meta_schema 
    = DBIx::DataModel->define_schema(class => $schema_name, %options);

Creates a new Perl class of name C<$schema_name> that represents a
database schema. That class inherits from L<DBIx::DataModel::Schema>.
At the same time, an instance of L<DBIx::DataModel::Meta::Schema> is
also created, for holding meta-information about that schema (for
example lists of classes, associations, types, etc. that will be
declared within the schema). 

The front-end and back-end method illustrated above
are both just a façade; they merely call
L<DBIx::DataModel::Meta::Schema/new>, where the real work is
performed. C<Schema()> returns the created class, while
C<define_schema()> returns the meta-schema instance.

Possible C<%options> are :

=over

=item class

Name of the Perl schema class to be created.

=item isa

Parent class(es) for that schema class (scalar or arrayref).
The default parent is L<DBIx::DataModel::Schema>.

=item auto_insert_columns

A hashref specifying columns to be automatically inserted
in every table. See L</define_auto_insert_columns()>.

=item auto_update_columns

A hashref specifying columns to be automatically updated
in every table. See L</define_auto_update_columns()>.

=item no_update_columns

A hashref specifying columns to be automatically ignored
in insert/update operations, for every table. 
See L</define_no_update_columns()>.

=item sql_no_inner_after_left_join

An optional boolean; if true, a LEFT OUTER JOIN in a multi-steps join
specification will force all subsequent joins to be also LEFT.
For example in the fake datamodel used in the rest of this documentation,
a join like

  HR->join(qw/Employee activities department)->...

would be interpreted as 

  T_Employee LEFT OUTER JOIN T_Activity ON ...
             LEFT OUTER JOIN T_Department ON ...

even if the association betwen C<Activity> and C<Department> is 
many-to-one (so theoretically this would result in a INNER JOIN by
default).

=item table_parent, join_parent

Optional application-specific classes, to be used instead of the
builtin classes, as parents for tables and joins declared in
this schema.

=item table_metaclass, join_metaclass, association_metaclass, path_metaclass, type_metaclass

Optional application-specific classes, to be used instead of the
builtin metaclasses, for instanciating meta-objects declared in this schema, .

=item statement_class

Optional application-specific class to be used instead of the
builtin class L<DBIx::DataModel::Statement> for instanciating 
statements.

=back



=head1 META-SCHEMA POPULATION (DECLARING TABLES, ASSOCIATIONS, etc.)

This chapter deals with all methods that will populate the
I<structure of a meta-schema> : declaring tables, associations, types,
navigation methods, etc. Such objects are defined statically and will
not change during program execution.

By contrast, the L</"SCHEMA PARAMETERS"> chapter deals with 
properties specific to each schema instance, such as 
database connection, debugging properties, etc.

=head2 Table() / define_table()

  # front-end method
  $schema_class->Table($class_name, $db_name, @primary_key, \%options);

  # or (back-end method)
  $meta_schema->define_table(%options);

Creates a new Perl class of name C<$class_name> that represents a
database table. The new class inherits from the C<table_parent> 
declared in the schema (by default : L<DBIx::DataModel::Source::Table>).
At the same time, an instance of the C<table_metaclass> is also
created (b< default : L<DBIx::DataModel::Meta::Source::Table>),
for holding meta-information about that table (database name, 
primary key, paths to other tables, etc.).

Both methods illustrated above call the L<DBIx::DataModel::Source::Table/new>
constructor, where the real work is performed. 
They return the C<$schema> or C<$meta_schema> on which they were invoked.


Possible C<%options> are :

=over

=item class => $string

Name of the class to be created.  If C<< $class_name >> contains no
C<::>, then the schema name is prepended to it (so the new table class
is created in the namespace of the schema, which is a recommended best
practice).

=item db_name => $string

SQL name of the database table or view that will be accessed through
this class.  Actually, it might be any SQL clause, like for example
C<Table1 t1 INNER JOIN Table2 t2 ON t1.fk=t2.pk>; see the L</View()>
method below.

=item primary_key => $string | \@array

Name of the column (or list of columns) that hold the primary key for
that table.

=item default_columns => $string

Whatever will be injected into SELECT statements, when no
C<-columns> parameter is explicitly supplied. The default
is C<'*'>.

=item where => \%hash | \@array

An optional reference to a WHERE condition, in 
L<SQL::Abstract::More> format. That condition
will be automatically injected into every SELECT statement
on this table. When working with regular tables, this parameter
is always empty; it is only useful for declaring C<DBIx::DataModel> 
views (see the L</View()> method below).

=item parents => [$parent1, ...]

List of meta-tables from which this table will inherit.  This can be
useful if your database supports table inheritance (like for example
PostgreSQL), and you want to reflect the inheritance structure 
within the Perl table classes.

=item aliased_tables

[TODO]

=item column_types

[TODO]

=item column_handlers


[TODO]

  {column1 => \%handlers1, ...}

where C<%handlers1> contains
  {handler_name_1 => coderef1, }

Associates some handlers to some columns in the current table class.
Then, when you call C<< $obj->apply_column_handler($handler_name) >> :
each column having a handler of the corresponding name will execute the
associated code. This can be useful for all sorts of data manipulation :

=over

=item *

converting dates between internal database format and user presentation format

=item *

converting empty strings into null values

=item *

inflating scalar values into objects

=item *

column data validation

=back


[TODO]

=item auto_insert_columns

[TODO]

=item auto_update_columns

[TODO]

=item no_update_columns

[TODO]

=back


=head2 View()

  $meta_schema->View($class_name, $default_columns, $db_tables, 
                     \%where, @parent_tables);

This is another front-end method for 
L<define_table()|/"Table() / define_table()">, 
for creating a new Perl class of name C<$class_name> that represents a
SQL SELECT request of shape 

  SELECT $columns FROM $db_tables [ WHERE %where ]

The optional list of C<< @parent_tables >> contains names of Perl 
table classes from which the view will also inherit.
If the SQL code in C<$db_tables> is a join between
several tables, then it is a good idea to mention these 
tables in C<< @parent_tables >>, so that their
path methods become available to instances
of this view. Be careful about table names : 
the SQL code in C<$db_tables> should contain I<database> table names,
whereas the members of C<< @parent_tables >> should be 
I<Perl> table classes.

Perl views as defined here have nothing to do with views declared in
the database itself. Perl views are totally unknown to the database,
they are just abstractions of SQL statements.  If you need to access
I<database views>, just use the C<Table()> declaration, like for a regular
table.


=head2 Association() / Composition() / define_association ()

  # front-end method
  $schema->Association([$class1, $role1, $multiplicity1, @columns1],
                       [$class2, $role2, $multiplicity2, @columns2]);

  # or (special kind of association)                       
  $schema->Composition([$class1, $role1, $multiplicity1, @columns1], 
                       [$class2, $role2, $multiplicity2, @columns2]);


  # or (back-end method)
  $meta_schema->define_association(
    name   => $association_name,          # optional
    kind   => $kind,                      # 'Association' or 'Composition'
    A      => {
      table        => $meta_table_instance,
      role         => $role_name,         # optional
      multiplicity => $multiplicity_spec, # ex. "1..*"
      join_cols    => [$col1, ...]        # optional
    },
    B      => { ... },                    # same structure as 'A'
  );


Declares an association between two tables (or even two instances of
the same table). The front-end methods shown above are equivalent to 

  $schema->metadm->define_association(
    A => {table        => $class1->metadm, role       => $role1, 
          multiplicity => $multiplicity1,  join_cols  => \@columns1},
    B => {table        => $class2->metadm, role       => $role2, 
          multiplicity => $multiplicity2,  join_cols  => \@columns2},
    kind => 'Association' # or 'Composition'
  );


The arguments are :


=over

=item A

A description of the first I<association end>, which is composed of

=over

=item table

An instance of L<DBIx::DataModel::Meta::Source::Table>.

=item role

The role name of that source within the association.
A Perl method of the same name will be defined in the
remote source (the other end of the association).
Besides, the role name is also used when building
joins through 

  $schema->join(qw/FirstTable role1 role2 .../)

One of the role names in the association can be
anonymous (undef), but not both. If anonymous, there
will be no Perl method and no possibility to join in that
direction, so it defines a unidirectional association.

If several associations attempt to define the same role name in
the same table, an exception is generated.

=item multiplicity

The multiplicity specification, i.e. the minimum and maximum 
number of occurrences of that association end, for any given
instance of the other end (if not clear, see UML textbooks).

The multiplicity can be expressed either as an 
arrayref C<< [$min, $max] >>, or as a string C<"$min..$max">.
The C<$max> can be C<'*'> or C<'n'>, which is interpreted
as the maximum integer value. If expressed as a string,
a mere C<'*'> is interpreted as C<'0..*'>, and a mere
C<'1'> is interpreted as C<'1..1'>.

Numbers different from C<0>, C<1> or C<*> may be given
as multiplicity bounds, but this will be just documentary :
technically, all that matters is

=over

=item *

whether the lower bound is 0 or more (if 0, generated
joins will be left joins, otherwise inner joins)

=item *

whether the upper bound is 1 or more (if 1, the associated
method returns a single object, otherwise it returns an arrayref)

=back


=item join_cols

An arrayref of columns that participate in the database join,
for this side of the association. The full database join will
be built by creating a C<LEFT|INNER JOIN ... ON ..> clause in
which the left-hand and right-hand sides of the C<ON> subclause
come from the C<join_cols> of both association ends.

This argument is optional: if absent, it will be filled
by default by taking the primary key of the table with minimum
multiplicity 1, for both sides of the association.
This default behaviour is convenient for data models where
primary keys and foreign keys are identical (for example C<dpt_id> both
as primary key in C<Department> and as foreign key in C<Activity>). 
Some data models have a different policy, where primary keys are 
always named the same (for example C<id>), and foreign keys
are named after the related table name : in such models, the default
does not work, and you have to specify the join columns
explicitly.

If the association is many-to-many (i.e. if the maximum
multiplicity is greater than 1 on both sides), then 
C<join_cols> takes a special meaning : it no longer
represents database columns, but rather represents 
two role names (in the sense just defined above) to follow
for reaching the remote end of the association.
Therefore C<join_cols> must contain exactly 2 items in that case :
the path to the intermediate table, and the path from the intermediate
table to the remote end. Here is again the example from 
L<DBIx::DataModel/SYNOPSIS> : 

  My::Schema->define_association(
    kind => 'Association',
    A    => {
      table        => My::Schema::Department->metadm,
      role         => 'departments',
      multiplicity => '*',
      join_cols    => [qw/activities department/],
    },
    B    => {
      table        => My::Schema::Employee->metadm,
      role         => 'employees',
      multiplicity => '*',
      join_cols    => [qw/activities employee/],
    },
  );

=back

=item B

A description of the second I<association end>, following exactly the 
same principles as for the C<'A'> end.

=item name

Optional name for the association (otherwise an implicit name
will be built by default from the concatenation of the role names).

=item kind

A string describing the association kind, i.e. one of :
C<Association>, C<Aggregation> or C<Composition>.

Compositions are associations with some additional semantics. In UML
class diagrams, compositions are pictured with a black diamond on one
side : this side will be called the I<composite> class, while the
other side will be called the I<component> class. In
C<DBIx::DataModel>, the diamond (the composite class) corresponds to
the C<A> association end, and the component class corresponds to the
C<B> end, so the order is important (while for plain associations the
order makes no difference).

The UML intended meaning of a composition is that objects of the
component classes cannot exist outside of their composite class. Within
C<DBIx::DataModel>, the additional semantics for compositions is to
support cascaded insertions and deletions, and auto-expansion; so the
special semantis attached to kind C<Composition> is :

=over

=item *

the multiplicity must be 1-to-n

=item * 

the C<'B'> end of the association (the "component" part) must not 
be component of another association (it can only be component of one
single composite table).

=item *

this association can be used for auto-expanding the composite object
(i.e. automatically fetching all component parts from the database)
-- see L<DBIx::DataModel::Source/expand>
and L</auto_expand>

=item *

this association can be used for cascaded inserts like

  $source->insert({
    column1 => $val1,
    ...
    $component_name1 => [{$sub_object1}, ...],
    ...
   })

see L</insert>

The main record will be inserted in the composite class, and within
the same transaction, subrecords will be inserted into the 
component classes, with foreign keys automatically filled with
appropriate values.


=item *

this association can be used for cascaded deletes : 
the argument to a C<delete> may contain lists of component records to
be deleted together with the main record of the composite class.


=back

=back


The association also creates instances of 
L<DBIx::DataModel::Meta::Path> for representing the 
directional paths between those sources.


=head2 Type()

  # front_end_method
  $schema->Type($type_name => 
     $handler_name_1 => sub { ... },
     $handler_name_2 => sub { ... },
     ...
   );

or in verbose form :

  $meta_schema->define_type(
     name     => $type_name,
     handlers => {
       $handler_name_1 => sub { ... },
       $handler_name_2 => sub { ... },
       ...
       },
   );

This declares a I<type>, which is just a hashref of handler names and
handler bodies (coderefs). The type can then be applied to some
columns in some tables; this is usually done in the Table declaration
(C<column_types> argument), or can be applied later through the
L</define_column_type> method.

Handlers receive the column value as usual through C<< $_[0] >>.
If the value is to be modified (for example for scalar
conversions or while inflating values into objects), 
the result should be put back into C<< $_[0] >>.
In addition to the column value, other info is passed to the
handler :

  $handler_body = sub {
    my ($column_value, $obj, $column_name, $handler_name) = @_;
    my $new_val = $obj->compute_new_val($column_value, ...);
    $column_value = $new_val; # WRONG : will be a no-op
    $_[0] = $new_val;         # OK    : value is converted
  }

The second argument C<< $obj >> is the object from where 
C<< $column_value >> was taken -- most probably an instance 
of a Table or Join class.  Use this if you need to read some contextual
information, but avoid modifying C<< $obj >> : you would most
probably get unexpected results, since the collection of 
available columns may vary from one call to the other.

Other arguments C<< $column_name >> and
C<< $handler_name >> are obvious.

Handler names B<from_DB> and B<to_DB> have a special
meaning : they are called automatically just after reading data from
the database, or just before writing into the database.
Handler name B<validate> is used by the method
L</"has_invalid_columns()">.

The L<DBIx::DataModel/SYNOPSIS> shows some examples for types 
"Date", "Percent" and "Multivalue".

A C<Type> does I<not> create a Perl class.


=head2 define_join()

This method builds or retrieves a pre-existing subclass of 
L<DBIx::DataModel::Source::Join>, and returns the associated
meta-object (an instance of L<DBIx::DataModel::Meta::Source::Join>).

  my $meta_join = $meta_schema->define_join($table, $path1, $path2, ..);

The join starts from a given table class and
follows one or several associations through their path names;
the resulting SQL request contains parameters
automatically inferred from the associations. So for example

  $meta_schema->define_join(qw/Department activities employee/);

is more or less equivalent to 

  my $sql = <<_EOSQL_
  Department 
    LEFT OUTER JOIN Activity ON Department.dpt_id = Activity.dpt_id
    LEFT OUTER JOIN Employee ON Activity.emp_id   = Employee.emp_id
  _EOSQL_
  
  $schema->View("Department=>activities=>employee", '*', $sql, 
                qw/Department Activity Employee/);

For each pair of tables, the kind of join is chosen according to the
multiplicity declared with that role in the association : if the
minimum multiplicity is 0, the join will be LEFT OUTER JOIN; otherwise
it will be a usual inner join (exception if 
C<< $meta_schema->sql_no_inner_after_left_join >> is true : after a first
left join, all remaining tables are also connected through additional
left joins). The default kind of join chosen by this rule may be
overriden by inserting intermediate connectors in the list, namely 
C<< '<=>' >> for inner joins and C<< '=>' >> for left joins.
So for example

  $meta_schema->define_join(qw/Department <=> activities <=> employee/);

becomes equivalent to 

  my $sql = <<_EOSQL_
  Department 
    INNER JOIN Activity ON Department.dpt_id = Activity.dpt_id
    INNER JOIN Employee ON Activity.emp_id   = Employee.emp_id
  _EOSQL_

Table names in the SQL statement correspond to what was defined
in the C<< $meta_schema->Table(...) >> declarations. However, tables may 
be aliased using C<|> as a separator :

  $meta_schema->define_join(qw/Department|dpt activities|act employee|emp/)
              ->select(-columns => qw/dpt.name act.d_begin emp.lastname/,
                       -where   => {"dpt.dpt_name" => {-like => "A%"}});

which generates

  SELECT dpt.name, act.d_begin, emp.lastname
  FROM Department AS dpt
    LEFT OUTER JOIN Activity AS act ON dpt.dpt_id = act.dpt_id
    LEFT OUTER JOIN Employee AS emp ON act.emp_id = emp.emp_id
  WHERE dtp.dpt_name like 'A%'

All tables participating in a C<join> are stacked,
and further roles are found by walking up the stack. So in

  ..->define_join(qw/FirstTable path1 path2 path3/)

we must find a C<path1> in C<FirstTable>, from which we 
know what will be the C<Table2>. Then, we must find 
a C<path2> in in C<Table2>, or otherwise in C<FirstTable>,
in order to know C<Table3>. In turn, C<path3> must be 
found either in C<Table3>, or in C<Table2>, or in C<FirstTable>, etc.
To resolve ambiguities, prefix the path by the name or alias of the
targeted source, such as :

  ..->define_join(qw/FirstTable path1|p1 
                     FirstTable.path2 
                     p1.path3|p3 
                     path2.path4/)

The name of the resulting join class will be composed by concatenating
table, connectors and path names, including optional aliases. If the
same sequence of table and paths was already encountered before, the
Perl class already exists, and its corresponding meta-object is returned;
otherwise, a new Perl class is created together with its meta-object.

The main purpose of C<define_join> is to gain efficiency in
interacting with the database. If we write

  foreach my $dpt (@{$schema->table('Department')->select}) {
    foreach my $act ($dpt->activities) {
      my $emp = $act->employee;
      printf "%s works in %s since %s\n", 
         $emp->{lastname}, $dpt->{dpt_name}, $act->{d_begin};
    }
  }

many database calls are generated behind the scene, in the loops that 
call the C<activities> and C<employee> methods.
Instead we could write 

  my $join = $meta_schema->define_join(qw/Department activities employee/);
  foreach my $row (@{$join->select}) {
    printf "%s works in %s since %s\n", 
      $row->{lastname}, $row->{dpt_name}, $row->{d_begin};
  }

which generates one single call to the database.


=head2 define_navigation_method

  $table->define_navigation_method($meth_name => qw/role1 role2 .../, 
                                   \%optional_select_args);

Inserts into the C<$table> class a new method named C<$meth_name>,
that will automatically call L</"define_join()"> and
then L<select()|/"select">, passing C<%optional_select_args> to the 
C<select> call. This is useful for joining several tables at once, so for
example with 

  $meta_schema->table('Department')->define_navigation_method(
    employees => qw/activities employee/
  );

we can then write 

  my $empl_ref = $some_dept->employees(-where   => {gender => 'F'},
                                       -columns => [qw/firstname lastname]);

This method is used internally to implement many-to-many associations;
so if you have only two roles to follow, you would probably be better
off by defining the association, which is a more abstract notion.
Direct calls to C<define_navigation_method> are still useful if you want
to follow three or more roles at once.

The last argument to C<define_navigation_method> is an optional 
hashref; if present, the hash will be passed as initial
argument to the C<select> call.


=head3 define_column_type()

  $meta_table->define_column_type($type_name, @column_names);

Registers type C<$type_name> to be applied to columns with
name in C<@column_names>, within the target C<$meta_table>.


=head3 define_column_handlers()

  $meta_table->define_column_handlers($column_name, 
    $handler_name_1 => sub { ... },
    ...
  );

Registers handlers to be applied to C<$column_name>,
within the target C<$meta_table>. The main purpose of this method
is for implementing the higher-level L</define_column_type()> method; 
however it can also be called directly, without the need for defining
a type.


=head3 define_auto_expand

  $meta_table->define_auto_expand(@component_names);

Generates an L</"auto_expand()"> method for the class, that 
will autoexpand on the roles listed (i.e. will call
the appropriate method and store the result
in a local slot within the object). 
In other words, the object knows how to expand itself,
fetching information from associated tables, in order
to build a data tree in memory.
Only component names declared through L<Composition()|/"Composition">
may be auto-expanded.

Be careful about performance issues: when an object uses
auto-expansion through a call to L</"autoExpand()">, every
auto-expanded role will generate an additional call to the
database. This might be slow, especially if there are recursive
auto-expansions; so in some cases it will be more appropriate to
flatten the tree and use database joins, typically through the method
L<join()|/"join">.

=head1 META-SCHEMA NAVIGATION

=head2 Meta-schema methods

=head3 tables

  my @meta_tables  = $meta_schema->tables;

Returns all of L<DBIx::DataModel::Meta::Source::Table> instances
declared in this C<$meta_schema>.

=head3 table

  my $meta_table   = $meta_schema->table($table_name);

Returns the single instance of L<DBIx::DataModel::Meta::Source::Table> 
with name C<$table_name>, or C<undef>.

=head3 associations

  my @associations = $meta_schema->associations;

Returns all of L<DBIx::DataModel::Meta::Association> instances
declared in this C<$meta_schema>.

=head3 association

  my $association  = $meta_schema->associations($association_name);

Returns the single instance of L<DBIx::DataModel::Meta::Source::Association> 
with name C<$association_name>, or C<undef>.


=head3 types

  my @types        = $meta_schema->types;

Returns all of L<DBIx::DataModel::Meta::Type> instances
declared in this C<$meta_schema>.

=head3 type

  my $type         = $meta_schema->type($type_name);

Returns the single instance of L<DBIx::DataModel::Meta::Type> 
with name C<$type_name>, or C<undef>.

=head3 joins

  my @joins        = $meta_schema->joins;

Returns all of L<DBIx::DataModel::Meta::Source::Join> instances
declared in this C<$meta_schema>.

=head3 join

  my $join         = $meta_schema->join($join_name);

Returns the single instance of L<DBIx::DataModel::Meta::Source::Join> 
with name C<$join_name>, or C<undef>.
  
=head3 other accessors

Accessor methods are defined for the following members of the
C<$meta_schema> : 

=over


=item class

=item sql_no_inner_after_left_join

=item auto_insert_columns

=item auto_update_columns

=item no_update_columns

=item table_parent

=item table_metaclass

=item join_parent

=item join_metaclass

=item association_metaclass

=item path_metaclass

=item type_metaclass

=item statement_class

=back

=head2 Meta-source methods

Accessor methods are defined for the following members of a 
C<$meta_source> (instance of either
L<DBIx::DataModel::Meta::Source::Table> or 
L<DBIx::DataModel::Meta::Source::Join>) : 

=over

=item schema

=item class

=item default_columns

=item parents

=item primary_key

=item aliased tables

=item name

=back

In addition, other methods are defined :

=head3 ancestors()

Returns a flattened list of recursive calls to the 
L</parents()> method.

=head3 auto_insert_column

Returns a flattened hash, built from C<auto_insert_columns> declared
in this source, in its ancestors, or in the C<$meta_schema>.

=head3 auto_update_column

Returns a flattened hash, built from C<auto_update_columns> declared
in this source, in its ancestors, or in the C<$meta_schema>.

=head3 no_update_column

Returns a flattened hash, built from C<no_update_columns> declared
in this source, in its ancestors, or in the C<$meta_schema>.
Keys are column names, values are insignificant.

=head3 path

Returns a flattened hash, built from C<no_update_columns> declared
in this source, in its ancestors, or in the C<$meta_schema>.

=head3 db_from

Returns what will be injected as
C<-from> argument into the 
L<SQL::Abstract::More/select> call.


=head3 where

Returns the optional "where" condition associated with
this source (in the case of L</View()>).


=head2 Meta-table methods

In addition to the C<$meta_source> methods above, 
the following methods are defined for an instance
of L<DBIx::DataModel::Meta::Source::Table> :


=head3 components

Returns the list of other meta-sources that have 
been declared as components of this source, through 
the L</Composition()> declaration.


=head2 Association methods

=head3 schema

The L<DBIx::DataModel::Meta::Schema> instance in which
this association is declared.


=head3 A

Returns the hashref describing the "A" end of the association.
Keys in the hashref are :

=over

=item table

The L<DBIx::DataModel::Meta::Source::Table> instance.

=item role

The optional string defining the role of this source
in the association. 

=item multiplicity

An arrayref C<< [$min, $max] >> of UML minimum and maximum multiplicity.

=item join_cols

An arrayref of column names participating in the join on this
side of the association.

=back


=head3 B

Returns the hashref describing the "B" end of the association.

=head3 name

Returns the association name

=head3 kind

Returns the association kind (C<Association> or C<Composition>).

=head3 path_AB

Returns the L<DBIx::DataModel::Meta::Path> object describing
the path from A to B.


=head3 path_BA

Returns the L<DBIx::DataModel::Meta::Path> object describing
the path from B to A.


=head2 Path methods

=head3 name

The name of this path.

=head3 from

Reference to the  L<DBIx::DataModel::Meta::Source> where this
path starts.

=head3 to

Reference to the  L<DBIx::DataModel::Meta::Source> where this
path ends.

=head3 on

Hashref for generating the join condition (keys are colums for the left-hand
side, values are columns for the right-hand side).

=head3 multiplicity

see L</Association methods>

=head3 association

Reference to the  L<DBIx::DataModel::Meta::Association> that created
this path.

=head3 direction

Either C<"AB"> or C<"BA">.


=head2 Type methods

=head3 schema

The L<DBIx::DataModel::Meta::Schema> instance in which
this type is declared.

=head3 name

Name of this type.

=head3 handlers

Hashref of handlers declared in this type (keys are handler names, values are
handler bodies, i.e. coderefs).


=head1 SCHEMA INSTANCIATION AND PARAMETERS

A C<$schema> is an I<instance> of a I<subclass> of 
L<DBIx::DataModel::Schema>. The subclass holds a reference
to a C<$meta_schema> where all information about tables, 
associations, etc. is kept. Each instance of that subclass
holds information about the database connection, the debugging
status, etc.

A schema subclass can have several instances; in that case, the application
runs in I<multi-schema> mode. However, multi-schema mode is only useful
in some special situations, like for example transferring data between
several databases; in most common cases, a I<single-schema> mode is 
enough. 

Single-schema mode is activated by default, which means that
all method calls can be performed directly on the subclass; the subclass
will manage a I<singleton> instance, and will delegate calls to that
singleton. This is the recommended way to work with C<DBIx::DataModel>,
because it uses less memory, and simplifies the application code (there 
is no need to pass a C<$schema> reference around between all modules).

If you need it, multi-schema mode is activated by calling the C<new()>
method, as many times as you need. Once this mode is activated, it is
not possible to go back to single-schema mode. Furthermore, multi-schema
mode should be activated before the singleton has been created, i.e. before
any call to the class methods below.

Because of this duality, all methods below, described
as C<< $schema->some_method(...) >>, can be called either as 
I<class> methods (single-schema mode), or as I<instance> methods
(multi-schema mode).

=head2 Schema::new()

  my $schema = $schema_subclass->new(%options);

As just explained, this activates multi-schema mode, and returns
a new schema instance. C<%options> may contain some initial settings
for C<dbh>, C<debug>, etc.; this is the same as creating the schema
first, and then calling the setter methods below
C<< $schema->dbh(...) >>, C<< $schema->debug(...) >>, etc.

=head2 dbh

  my $dbh = DBI::connect(...);
  $schema->dbh($dbh, %options);        # set
  $schema->dbh([$dbh, %options]);      # set, alternative syntax

  my $dbh             = $schema->dbh;  # get back just the dbh
  my ($dbh, %options) = $schema->dbh;  # get back all

Returns or sets the handle to a DBI database handle (see L<DBI>). 
This handle is schema-specific.
C<DBIx::DataModel> expects the handle to be opened with
C<< RaiseError => 1 >>
(see L</"Transactions and error handling">).

In C<%options> you may pass any key-value pairs, and retrieve
them later by calling C<dbh> in a list context,
which may be useful for holding driver-specific information.
C<DBIx::DataModel> will only inspect those options for knowing
how to retrieve database-generated keys (see the L</"insert"> method 
below).

Changing the database handle through the C<dbh> method 
is forbidden while a transaction is in course.
However, a nested transaction may temporarily change
the database handle by supplying it as argument to the 
L</do_transaction> method.

To unset the database handle, call C<< $schema->dbh(undef) >>.

=head2 debug

  $schema->debug(1);             # will warn for each SQL statement
  $schema->debug($debug_object); # will call $debugObject->debug($sql)
  $schema->debug(undef);         # turn off debugging

Debug mode is useful for seeing SQL statements generated 
by C<DBIx::DataModel>. 
Enabling debugging with a C<$debug_object>
will typically be useful in conjunction with something like 
L<Log::Log4perl|Log::Log4perl> or 
L<Log::Dispatch|Log::Dispatch>.
Otherwise, enabling debugging with just any true scalar
will print SQL statements on STDERR.

There is also another way to see the SQL code for one particular statement :

  my $spy_sql = sub {my ($sql, @bind) = @_;
                     print STDERR join "\n", $sql, @bind;
                     return ($sql, @bind);};
  
  my $result = $source->select(-columns   => \@columns,
                               -where     => \%criteria,
                               -post_SQL  => $spy_sql);

=head2 sql_abstract

  $schema->sql_abstract($an_SQL_Abstract_More_instance); # set
  my $sqlam = $schema->sql_abstract;                     # get

Sets or retrieves the instance of L<SQL::Abstract::More> used 
by this C<$schema>. If the client code does not set it explictly,
an instance wil be implicitly created.

=head2 dbi_prepare_method

  $schema->dbi_prepare_method($method);      # set
  my $method = $schema->dbi_prepare_method;  # get

Sets or retrieves the method sent to L<DBI> for preparing SQL statements.
The default is C<"prepare">; it can be set to C<"prepare_cached"> instead.


=head2 placeholder_prefix

  $schema->placeholder_prefix($prefix);      # set
  my $prefix = $schema->placeholder_prefix;  # get

Sets or retrieves the prefix string to recognize "named placeholders"
within a statement. That prefix should never match any regular data
encountered in your application; the default is C<'?:'>.

=head2 select_implicitly_for

  $schema->select_implicitly_for($string);      # set
  my $string = $schema->select_implicitly_for;  # get

Sets  or retrieves a default value for the C<-for> argument to 
L<select()|/"select">. 

This default value is not set for statements with 
C<< -result_as => 'subquery' >> (because the FOR clause in an 
SQL statement only makes sense at the top level, not in a subquery).


=head2 localize_state

  {
    my $scope_guard = $schema->localize_state(@schema_members_to_localize);

    ... # do some work, possibly change state
  
  } # $scope_guard out of scope : previous state of $schema is restored 


Applies dynamic scoping to a C<$schema>, like Perl's
C<local> construct (see L<perlsub/"Temporary Values via local">).  Here
however, since C<local> is not perfectly suited for private class
data, we provide a solution which is similar in spirit, but slightly
different in implementation. The C<localize_state> method 
internally takes a copy of the current state, and returns
a handle to it. The handle should be stored in a C<my> variable;
when that variable goes out of scope (at block exit), then
the previous state is restored.

The optional argument C<@schema_members_to_localize> specifies
precisely which schema members should be localized. If it is empty,
the default list is : C<dbh>, C<dbh_options>, C<debug>, 
C<select_implicitly_for>, C<dbi_prepare_method>. 




=head1 DATA RETRIEVAL AND MANIPULATION

=head2 do_transaction

  my $coderef = sub {$table1->insert(...); $table2->update(...); ...};
  $schema->do_transaction($coderef);

Evaluates the code within a transaction. In case of failure, the
transaction is rolled back, and an exception is raised, with a message
containing the initial error and the status of the rollback (because
the rollback itself may also fail). If you need finer details,
you can treat the exception as an object with two methods C<initial_error>
and C<rollback_errors>:

    eval {$schema->do_transaction($coderef); 1}
    or do {my $err = $@;
           explain($err->initial_error, $err->rollback_errors)};

Usually the coderef passed as argument will be a
closure that may refer to variables local to the environment where
the closure was created.

Nested calls to C<do_transaction> are supported : only 
the top-level call will actually initiate and then
commit the transaction, while an exception at any level
will abort and rollback the whole thing.

If the nested transaction needs to temporarily work on a different 
database handle, it may do so by supplying the dbh and its
options as additional arguments :

  $schema->do_transaction($coderef, $new_dbh, %new_dbh_options);

When called in this form, C<do_transaction> will temporarily
set the dbh to the supplied value, and then return to the 
previous value when the nested transaction is finished.
Commits on all involved database handles are delayed until
the top-level transaction is finished.

There is no support (yet!) for nested transactions with
intermediate savepoints.

=head2 fetch

  my $record = $table->fetch(@key_values, \%options);

Fetches a single record from a table, from its primary key value
(on one or several columns).
C<%options> may specify things like C<-for>, C<-pre_exec>,
C<-post_exec>, etc. 

This method is just syntactic sugar for 

  my $record = $table->select(-fetch => \@key_values, %options);

(see below).


=head2 fetch_cached

  my $record = $table->fetch_cached(@key_values, \%options);

Like C<fetch>, except that the result is stored in a cache,
and further calls to the same methods with the same
parameters will return the cached record instead of going
back to the database. The cache does not know about any updates 
to the database, so this is mainly useful for readonly data.

The cache is stored internally in
C<< $table->metadm->{fetch_cached}{$dbh_addr}{$freeze_args} >>
(where C<$dbh_addr> is C<< Scalar::Util::refaddr(MyTable->dbh) >>
and C<$freeze_args> is C<< Storable::freeze(@keyValues, \%options) >>).
Client code may use this information to clear the cache or tie it to 
a more sophisticated caching module.

=head2 select

Given a C<$target>, which could be either a 
L<table|DBIx::DataModel::Doc::Glossary/table>, a 
L<view|DBIx::DataModel::Doc::Glossary/join> or a 
L<statement|DBIx::DataModel::Doc::Glossary/statement> :

  $records = $target->select(
     -columns       => \@columns, 
       # OR : -columns => [-distinct => @columns],
     -where         => \%where,
       # OR : -fetch => $key,
       # OR : -fetch => \@key,
     -group_by      => \@groupings,
     -having        => \%criteria,
     -order_by      => \@order,
     -for           => $purpose,
     -post_SQL      => sub {...},
     -pre_exec      => sub {...},
     -post_exec     => sub {...},
     -post_bless    => sub {...},
     -prepare_attrs => \%attrs,
     -limit         => $limit,
     -offset        => $offset,
     -page_size     => $pageSize,
     -page_index    => $pageIndex,
     -column_types  => \%columnTypes,
     -result_as     => 'rows'      || 'firstrow' 
                    || 'hashref'   || [hashref => @cols]
                    || 'sth'       || 'sql' 
                    || 'subquery'  || 'flat_arrayref' 
                    || 'statement' || 'fast_statement'
  );
  

Applies a SQL SELECT to the C<$target>, and returns a
result as specified by the C<-result_as> argument (see below).

Arguments are all optional and are passed by name.


=head3 Named arguments to C<select()>


=over

=item C<< -columns => \@columns >> 

C<< \@columns >>  is a reference to an array
of SQL column specifications (i.e. column names, 
C<*> or C<table.*>, functions, etc.).

Initial words in C<@columns> that start with a hyphen 
are treated as verbatim SQL : in particular, 
C<< -columns => [-DISTINCT => qw/col1 col2 .../] >>
will yield 

  SELECT DISTINCT col1, col2, ... FROM ...

A '|' in a column is translated into an 'AS' clause, according
to the current SQL dialect in L<SQL::Abstract::More> : this is convenient when
using perl C<< qw/.../ >> operator for columns, as in

  -columns => [ qw/table1.longColumn|t1lc table2.longColumn|t2lc/ ]

Column aliasing should be avoided on key columns (either primary or 
foreign keys), because role methods will no longer be able
to navigate through the joins (currently C<DBIx::DataModel> is 
not clever enough to rename its internal join constraints according
to column aliases). Aliasing on non-key columns is OK, and 
column handlers will operate properly on aliased columns.

The argument to C<-columns> can also be a string instead of 
an arrayref, like for example
C<< "c1 AS foobar, MAX(c2) AS m_c2, COUNT(c3) AS n_c3" >>;
however this is mainly for backwards compatibility. The 
recommended way is to use the arrayref notation as explained above :

  -columns => [ qw/  c1|foobar   MAX(c2)|m_c2   COUNT(c3)|n_c3  / ]

If omitted, C<< \@columns >> takes the default, which is
usually '*', unless modified through the C<default_columns> argument
to the L<table declaration|/Table()>.

No verification is done on the list of retrieved C<< \@columns >>,
so the list does not have to include the primary or foreign keys --- 
but then later attempts to perform joins or updates will obviously fail.


=item C<< -distinct => \@columns >> 

behaves like the C<< -columns >> arguments, except that 
keyword C<DISTINCT> will be included in the generated SQL.


=item C<< -where => \%where >> 

C<< \%where >> is a reference to a hash or array of 
criteria that will be translated into SQL clauses. In most cases, this
will just be something like C<< {col1 => 'val1', col2 => 'val2'} >>;
see L<SQL::Abstract::select|SQL::Abstract/select> for 
 detailed description of the
structure of that hash or array. It can also be
a plain SQL string like C<< "col1 IN (3, 5, 7, 11) OR col2 IS NOT NULL" >>.



=item C<< -fetch => \@columns >>

equivalent to 

  ...->select(-where => {<primary_key_column0> => $columns[0],
                         <primary_key_column1> => $columns[1], ...},
              -result_as => "firstrow")

If the primary key ranges on one single column (which is the most
frequent case), then the argument to C<-fetch> can also be
a single scalar value :

  ...->select(-fetch => $key)

When calling a table directly, the C<< select(-fetch => ..) >> syntax 
is awkward; you will most certainly prefer the syntactic
sugar offered by the L<fetch()|"fetch"> method :

  $table->fetch(@key)

However, the C<-fetch> notation is useful when walking through
association roles :

  $employee->activities(-fetch => $act_id)

This example will generate the following SQL 

  SELECT * FROM activity WHERE act_id=$act_id AND emp_id=$employee->{emp_id}

Notice how this is different from 

  $schema->table('Activity')->fetch($act_id)

which would generate

  SELECT * FROM activity WHERE act_id=$act_id

Both examples would end up with the same record, but in the first
case there is an additional check that this record really
belongs to the given employee.

In presence of C<-fetch>, arguments C<-where> and C<-select_as> are not
allowed.


=item C<< -group_by => "string" >>  or C<< -group_by => \@array >> 

adds a C<GROUP BY> clause in the SQL statement. Grouping columns are
specified either by a plain string or by an array of strings.

=item C<< -having => "string" >>  or C<< -having => \%criteria >> 

adds a C<HAVING> clause in the SQL statement (only makes
sense together with a C<GROUP BY> clause).
This is like a C<-where> clause, except that the criteria
are applied after grouping has occured.

=item C<< -order_by => \@order >> 

C<< \@order >> is a reference to a list 
of columns for sorting. It can also be a plain SQL string
like C<< "col1 DESC, col3, col2 DESC" >>. Columns can 
also be prefixed by '+' or '-' for indicating sorting directions,
so for example C<< -orderBy => [qw/-col1 +col2 -col3/] >>
will generate the SQL clause
C<< ORDER BY col1 DESC, col2 ASC, col3 DESC >>.


=item C<< -for => $clause >> 

specifies an additional clause to be added at the end of the SQL statement,
like C<< -for => 'read only' >> or C<< -for => 'update' >>.

=item C<< -post_SQL => sub{...} >>

hook for specifying a callback function to be called on SQL code and
bind values, before preparing the statement. It will be called as
follows:

  ($sql, @bind) = $args->{-post_SQL}->($sql, @bind) if $args->{-post_SQL};


=item C<< -pre_exec => sub{...}, -post_exec => sub{...} >>

hooks for specifying callback functions to be called on the DBI statement
handle, just before or just after invoking C<< execute() >>. So the sequence
will be more or less like this:

  $sth = $dbh->prepare($sql_statement);
  $pre_exec_callback->($sth)  if $pre_exec_callback;
  $sth->execute(@bind_values);
  $post_exec_callback->($sth) if $post_exec_callback;

This is mostly useful if you need to call driver-specific functions at 
those stages.

=item C<< -post_bless => sub{...} >>

hook for specifying a callback function to be called on data rows.
The callback will be called I<after> L<bless_from_DB|bless_from_DB>, 
i.e. the row is already an object of the proper class and 
column handlers have been applied.


=item C<< -prepare_attrs => \%attrs >>

Optional attributes that will be transmitted
to L<DBI/prepare>.

=item C<< -page_size => $page_size >>

specifies how many rows will be retrieved per "page" of data.
Default is unlimited (or more precisely the maximum 
value of a short integer on your system).
When specified, automatically implies C<< -limit >>.

=item C<< -page_index => $page_index >>

specifies the page number (starting at 1). Default is 1.
When specified, automatically implies C<< -offset >>.

=item C<< -limit => $limit >>

limit to the number of rows that will be retrieved.
Automatically implied by C<< -page_size >>.

=item C<< -offset => $offset >>

Automatically implied by C<< -page_index >>.

=item C<< -column_types => \%column_types >>

dynamically specifies some column types I<at the statement level>.
Usually column types are defined within tables at compile time, but
it may be necessary to defined additional types within the 
statement, for example when using database functions and/or aliases.
The argument is a hashref in which keys are names of column
types defined within the schema, and values are arrayrefs
of column names :

   select(-columns     => [qw/ MAX(date_col)|max_date 
                               MIN(date_col)|min_date ... /],
          -column_types => { Date => [qw/max_date min_date/] },
          ...)


=item C<< -result_as => $result_kind >>

specifies what kind of result will be produced. 
The result is always a scalar and does not depend on the
calling context.
Possible result kinds are :

=over

=item B<rows>

The result will be a ref to an array of rows, blessed into objects of the 
class. This is the default result kind. If there are no data rows, a ref
to an empty list is returned.

=item B<firstrow>

The result will be just the first data row, blessed into an object of the 
class. If there is no data, C<undef> is returned.


=item B<hashref> || B<< [hashref => @cols] >>

The result will be a hashref. Keys in the hash correspond to distinct
values of the specified columns, and values are data row objects.
If the argument is given as C<< [hashref => @cols] >>, the column(s)
are specified by the caller; otherwise if the argument is given
as a simple string, C<@cols> will default to C<< $source->primary_key >>.
If there is more than one column, the result will be a tree of nested hashes.
This C<-result_as> is normally used only where the key fields values 
for each row are unique. If multiple rows are returned with the same
values for the key fields then later rows overwrite earlier ones.


=item B<flat_arrayref>

The result will be a ref to an array that concatenates results
from each row. Usually this is combined with a C<-columns>
argument with one single column, to get a vertical slice from a resultset,
like in 

  my $all_names = $schema->table('People')->select(
    -columns   => [-DISTINCT => qw/firstname/],
    -result_As => 'flat_arrayref',
   );
  print sort @$all_names;

However, it may also be used for example to fill a hash from
pairs retrieved from each row, like in 

  my $pairs = $schema->table('People')->select(
    -columns   => [qw/pers_id firstname/],
    -result_as => 'flat_arrayref'
   );
  my %hash = @$pairs;

Finally, it can be convenient for avoiding column aliases,
when using aggregator functions :

  my $array_ref = $source->select(-columns  => [qw/MAX(col1)
                                                  AVG(col2)
                                                  COUNT(DISTINCT(col3))/],
                                  -where     => ...,
                                  -result_as => 'flat_arrayref');
  my ($max_col1, $avg_col2, $count_col3) = @$array_ref;


=item B<statement>

The result will be an instance of a
L<DBIx::DataModel::Statement|DBIx::DataModel::Statement>.
That object has a  C<next> method that fetches the 
next datarow and blesses it into the appropriate object, or
returns C<undef> when there is no more data to fetch.
So a typical usage pattern is :

  my $statement = $class->select(-where     => \%criteria, 
                                 -result_as => 'statement');
  while (my $row = $statement->next) {
    do_something_with($row);
  }


If called with an argument, the C<next> method
returns an array ref of several rows, as in

 my $rows = $statement->next(10);

Finally, the statement also has an C<all> method that returns
an arrayref of all remaining rows.

When creating a new Schema, a different statement class 
can be specified via the C<statement_class> argument.
For example the
L<DBIx::DataModel::Statement::JDBC|DBIx::DataModel::Statement::JDBC>
subclass in this distribution is intended for
L<DBD::JDBC|DBD::JDBC> data sources, and gives access to some 
JDBC methods over the statement (for example positioning instructions).


=item B<fast_statement>

The result is like a normal statement, except that rows are successively
fetched into the same memory location, using DBI's L<fetch|DBI/fetch>
and L<bind_columns|DBI/bind_columns> methods. This is the fastest way
to get data; however, pay attention to this warning from L<DBI's
documentation|DBI/fetchrow_arrayref> : I<Note that the same array
reference is returned for each fetch, so don't store the reference and
then use it after a later fetch. Also, the elements of the array are
also reused for each row, so take care if you want to take a reference
to an element>. Furthermore, any field added into the row will remain
present for the next rows.

Of course it is not possible to call C<< all >>
or C<< next(10) >> on a fast statement. 

=item B<sth> 

The result will be an executed C<DBI> statement handle. Then it is up to the 
caller to retrieve data rows using the DBI API.
If needed, these rows can be later blessed into appropriate objects
through L<bless_from_DB()|/"bless_from_DB">.


=item B<sql> 

In scalar context, the result will just be the generated SQL statement. 
In list context, it will be C<($sql, @bind)>, i.e. the SQL statement 
together with the bind values.

=item B<subquery> 

Returns a ref to an arrayref containing C<< \["($sql)", @bind] >>. 
This is meant to be passed to a second
query through L<SQL::Abstract|SQL::Abstract>, as in :

  my $subquery = $source1->select(..., -resultAs => 'subquery');
  my $rows     = $source2->select(
      -columns => ...,
      -where   => {foo => 123, bar => {-not_in => $subquery}}
   );

=back

=back


=head2 unbless

  $schema->unbless($obj1, $obj2, ...);

Recursively applies L<Acme::Damn/damn> to remove all class information 
from its arguments : these become plain Perl hashrefs, arrayrefs or scalars.

This may be useful if the datatree returned by a C<select(..) / expand(..) >
needs to be exported through an external module that only considers
plain datastructures; this is the case for example with L<YAML::Syck/Dump>.


=head2 insert

  my @ids = $table->insert({col1 => $val1, col2 => $val2, ...}, 
                           {...},
                           %options);
  # or
  my @ids = $table->insert([qw/ col1   col2   .../],
                           [    $val1, $val2, ... ],
                           ...);

Inserts a collection of rows into the database, given
either as a list of hashrefs, or as a first arrayref containing
the column names, followed by a list of arrayrefs containing
values for each row to be inserted.

In either form, the method applies the C<to_DB> handlers, removes the
C<no_update> columns, and then inserts the new records into the
database.  Because of the handlers, this operation I<may modify the
argument data>, so it is not safe to access C<$val1>, C<$val2>,
etc. after the call.

Primary key column(s) should of course be present 
in the supplied hashrefs, unless the the key is auto-generated
by the database (see below). 

Each hashref will be blessed into the C<$table> class, and
will be inserted through the internal 
L<_singleInsert()|/"_singleInsert"> method.
The default implementation of this method should be good enough
for most common uses, but you may want to refine it in your
table classes if you need some fancy handling on primary keys
(like for example computing a random key and checking whether
that key is free). The default implementation uses the following
algorithm to retrieve keys auto-generated by the database :

=over

=item *

if a dbh option called C<last_insert_id> is found (see options 
passed to the L</"dbh"> method), this is taken as a 
callback function, which gets called as

  $dbh_options{last_insert_id}->($dbh, $table_name, $column_name)

=item *

if options called C<catalog> and/or C<schema> are found,
C<DBIx::DataModel> will call 

  $dbh->last_insert_id($dbh_options{catalog}, $dbh_options{schema},
                       $table_name, $column_name)

=item *

otherwise, C<DBIx::DataModel> will call 

  $dbh->last_insert_id(undef, undef, undef, undef)

=back

If the table is a composite class (see L<Composition()|/"Composition">
above), then the component parts may be supplied within the hashref,
with keys equal to the role names, and values given as arrayrefs of
sub-hashrefs; then these will be inserted into the database, at the
same time as the main record, with join values automatically filled
in (cascaded insert).  For example :

   HR::Employee->insert({firstname  => "Johann Sebastian",  
                         lastname   => "Bach",
                         activities => [{d_begin  => '01.01.1695',
        			         d_end    => '18.07.1750',
	        		         dpt_code => 'CPT'}]});


The C<insert()> call may take a list of B<%options> 
specified at the I<end> of the argument list (notice they are
I<not> given as a hashref, but as a mere hash, or list of pairs).
Actually the only option currently supported is 
B<-returning>, with an argument that may be either a scalar, an
arrayref or an empty hashref :

=over

=item *

if it is a scalar or an arrayref, that value is passed
to L<SQL::Abstract/insert> and finally to the SQL level 
(INSERT ... RETURNING ...);  whatever is returned from the 
database for each single record gets flattened into a single
list transmitted back to the caller.

  my @result = $table->insert({...}, ..., -returning => $scalar_or_arrayref);

=item *

if it is an empty hashref, the return value is also a list of hashrefs
(one for each inserted record), containing the column name(s) and
value(s) of the primary key for that record, and possibly containing
subhashes or subarrays for other records created through cascaded
inserts. For example:

  my @result = HR::Employee->insert({..., activities => [{...}, ...]},
                                    ...,
                                    -returning => {});
  my $prim_key_first_emp = $result[0]{emp_id};
  my $prim_key_first_act = $result[0]{activities}[0]{act_id};

=item *

if the C<-returning> option is absent, values returned by calls to
L<_singleInsert()|/"_singleInsert"> are collected into a flattened
array, and then returned by C<insert()>; usually, these are the
primary keys of the inserted records.  If this array contains several
values and C<insert()> was called from a scalar context, a warning is
issued.

=back



=head2 update

  $table->update({col1 => $val1, ...});
  $table->update(@primary_key, {col1 => $val1, ...});
  $table->update(-set   => {col1 => $val1, ...},
                 -where => \%condition);
  $obj->update;

This is both a class and an instance method, with several syntaxes.
It applies the C<to_DB> handlers, removes the C<no_update> columns, 
and then updates the database for the given record.

When called as a class method, the columns and values to update
are supplied as a hashref. The second syntax with 
C<< @primary_key >> is an alternate way to supply the values
for the primary key (it may be more convenient because you don't
need to repeat the name of primary key columns). So if C<emp_id>
is the primary key of table C<Employee>, then the following
are equivalent :

  HR::Employee->update({emp_id  => $eid, 
                        address => $newAddr, 
                        phone   => $newPhone});
  HR::Employee->update($eid => {address => $newAddr, 
                                phone   => $newPhone});

The third syntax with C<-set> and C<-where> keywords
is used for simultaneously updating several
records (bulk update); it will send one single SQL request of shape

  UPDATE table SET col1='val1', ... WHERE ...

but in that case, since the data did not transit through Perl objects,
no column handers will be applied.

When called as an instance method, i.e. 

  $someEmployee->update;

the columns and values to update are taken from the object in 
memory (ignoring all non-scalar values). 

The C<update> method only updates the columns received
as arguments : it knows nothing about other columns that may sit
in the database table. Therefore if you have two concurrent clients
doing

  (client1)  $table->update($id, {c1 => $v1, c2 => $v2});
  (client2)  $table->update($id, {c3 => $v3, c4 => $v4, c5 => $v5});

the final state of record C<$id> in the database will 
reflect changes from both clients. 


=head2 delete

  $table->delete({column1 => value1, ...});
  $table->delete(@primary_key);
  $table->delete(-where => \%condition);
  $row->delete;

This is both a class and an instance method.
It deletes a record from the database.

When called as a class method, the primary key of the record 
to delete is supplied either as a hashref, or directly
as a list of values. Note that C<< $table->delete(11, 22) >>
does not mean "delete records with keys 11 and 22", but rather
"delete record having primary key (11, 22)"; in other words,
you only delete one record at a time. 

The syntax with the C<-where> keyword
is used for simultaneously updating several
records (bulk update); it will send one single SQL request of shape

  DELETE FROM table WHERE ...

When called as an instance method, the primary key is taken from
object columns in memory. If the table is a composite class (see
L<Composition()|/"Composition"> above), and if the object contains
references to lists of component parts, then those will be recursively
deleted together with the main object (cascaded delete). However, if
there are other component parts in the database, not referenced in the
hashref, then those will not be automatically deleted : in other
words, the C<delete> method does not go by itself to the database to
find all component parts (this is the job of the client
code, or sometimes of the database itself).


[CONTINUE HERE]


=head2 applyColumnHandler

  $class ->applyColumnHandler($handlerName, \@objects);
  $object->applyColumnHandler($handlerName);

Inspects the target object or list of objects; for every
column that exists in the object, checks whether
a handler named C<< $handlerName >> was declared for
that column (see method L</ColumnHandlers>), and if so, 
calls the handler. By this definition, if a column
is I<absent> in an object, then the handler for that column
is not called, even though it was declared in the class.

The results of handler calls are collected into a hashref, with an
entry for each column name.  The value of each entry depends on how
C<< applyColumnHandlers >> was called : if it was called as an
instance method, then the result is something of shape

  {columnName1 => resultValue1, columnName2 => resultValue2, ... }

if it was called as a class method (i.e. if C<< \@objects >> is defined),
then the result is something of shape

  {columnName1 => [resultValue1forObject1, resultValue1forObject2, ...], 
   columnName2 => [resultValue2forObject1, resultValue2forObject2, ...], 
   ... }

If C<columnName> is not present in the target object(s), then the 
corresponding result value is  C<undef>.


=head2 hasInvalidColumns

  my $invalid_columns = $obj->hasInvalidColumns;
  if ($invalid_columns) {
    print "wrong data in columns ", join(", ", @$invalid_columns);
  }
  else {
   print "all columns OK";
  }


Applies the 'validate' handler to all existent columns.
Returns a ref to the list of invalid columns, or
undef if there are none.

Note that this is validation at the column level, not at the record
level. As a result, your validation handlers can check if an existent
column is empty, but cannot check if a column is missing (because in
that case the handler would not be called).

Your 'validate' handlers, defined through L</ColumnHandlers>,
should return 0 or an empty string whenever the column value is invalid.
Never return C<undef>, because we would no longer be able to
distinguish between an invalid existent column and a missing column.


=head2 expand

  $obj->expand($role [, @args] )

Executes the method C<< $role >> to follow an Association,
stores the result in the object itself under C<< $obj->{$role} >>,
and returns that result.
This is typically used to expand an object into a tree datastructure.
Optional C<< @args >> are passed to C<< $obj->$role(@args) >>, for
example for specifying C<-where>, C<-columns> or C<-orderBy> options.

After the expansion, further calls to 
C<< $obj->$role >> (without any arguments) will reuse 
that same expanded result instead of calling again the database.
This caching improves efficiency, but also introduces the risk
of side-effects across your code : after 

  $obj->expand(someRole => (-columns => [qw/just some columns/],
                            -where   => {someField => 'restriction'}))

further calls to C<< $obj->someRole() >> will just return
a dataset restricted according to the above criteria, instead
of a full join. To prevent that effect, you would need to 
C<< delete $obj->{someRole} >>, or to call the role
with arguments : C<< $obj->someRole('*') >>.



=head2 autoExpand

  $record->autoExpand( $recurse );

Asks the object to expand itself with some objects in foreign tables.
Does nothing by default. Should be redefined in subclasses,
most probably through the 
L</AutoExpand> method (with capital 'A').
If the optional argument C<$recurse> is true, then 
C<autoExpand> is recursively called on the expanded objects.



=head2 blessFromDB

  $class->blessFromDB($record);

Blesses C<< $record >> into an object of the table or view class,
and applies the C<fromDB> column handlers.


=head2 primKey

  my @primKeyColumns = $source->primKey;
  my @primKeyValues  = $obj->primKey;

If called as a class method, returns the list of columns
registered as primary key for that table (via C<< Schema->Table(..) >>),
or computed as primary key for that view (concatenation of primary
keys of joined tables that are in a 1-to-many association).

If called as an instance method, returns the list of values 
in those columns.

When called in scalar context and the primary key has only one column,
returns that column (so you can call C<< $my k = $obj->primKey >>).




=head1 DEPRECATED METHODS

Here are some deprecated methods from previous versions

=over

=item *

C<ViewFromRoles> is now called L</"join"> (class method in C<Schema>)

=item *

C<selectFromRoles> is now called L</"join"> (instance method in C<Source>)

=item *

C<MethodFromRoles> is now called L</"MethodFromJoin"> (class method in C<Source>)

=item *

C<selectSth> is now writen C<< select(..., resultAs => "sth") >>

=item *

C<SqlDialect> is now expressed as argument to L<Schema()|/Schemae>

=item *

C<applyColumnHandlers> is now called C<applyColumnHandler>

=item *

C<keepLasth> and C<lasth> are no longer needed; if you want to 
interact with the database statement handle, use the 
L<DBIx::DataModel::Statement|DBIx::DataModel::Statement> API.

=item *

C<preselectWhere> is no longer needed (superseded by the
C<Statement::refine> method).

=item *

C<-postFetch> in C<< select(..., -postFetch => sub {... } ... ) >>
is now called C<-postBless>


=back




=head1 OLD_STUFF

=head2 OLD_STUFF


=head3 join as class method within a Table or View

  my $statement = $table->join(qw/role1 role2 .../)->prepare;

Starting from a given table, returns a reference to a 
L<statement|DBIx::DataModel::Statement> that
selects a collection of data rows from associated tables, performing
the appropriate joins.  Internally this is implemented throught the
C</define_join()> method, with an additional join criteria to constrain
on the primary key(s) of C<$table>.  That statement cannot
be executed yet, because the values of the primary key are not
known until we have an instance of C<$table>; but the statement
can already be
L<prepare|DBIx::DataModel::Statement/prepare>d.
Later on, we can 
L<execute|DBIx::DataModel::Statement/execute> 
the statement by binding it to an instance
of C<$table> :

   my $obj = $table->fetch(...);
   my $rows = $statement->execute($obj)->all;

=head3 join as instance method within a Table or View

Creates a statement as just explained above, and immediately
binds it to the current object. 
So for example if C<< $emp->{emp_id} == 987 >>, then

  $emp->join(qw/activities department/)
      ->select(-where => {d_end => undef})

will generate

  SELECT * FROM Activity INNER JOIN Department 
                         ON Activity.dpt_id = Department.dpt_id
           WHERE  emp_id = 987 AND d_end IS NULL



=head2 AutoInsertColumns

  $schema->AutoInsertColumns( columnName1 => sub{...}, ... );
  $table ->AutoInsertColumns( columnName1 => sub{...}, ... );

Declares handler code that will automatically fill column names
C<columnName1>, etc. at each insert, either for a single table, or (if
declared at the Schema level), for every table. For example, each
record could remember who created it and when with something
like

  $schema->AutoInsertColumns( created_by => 
    sub{$ENV{REMOTE_USER} . ", " . localtime}
  );

The handler code will be called as 

  $handler->(\%record, $table)

so that it can know something about its calling context.  In most
cases, however, the handler will not need these parameters, because it just
returns global information such as current user or current date/time.


=head2 AutoUpdateColumns

  $schema->AutoUpdateColumns( columnName1 => sub{...}, ... );
  $table ->AutoUpdateColumns( columnName1 => sub{...}, ... );

Just like C<AutoInsertColumns>, but will be called automatically
at each update B<and> each insert. This is typically used to 
remember the author and/or date and time of the last modification
of a record. If you use both C<AutoInsertColumns> and 
C<AutoUpdateColumns>, make sure that the column names are not 
the same.

When doing an I<update> (i.e. not an insert), the
handler code will be called as 

  $handler->(\%record, $table, \%where)

where C<%record> contains the columns to be updated and
C<%where> contains the primary key (column name(s) and value(s)).

=head2 NoUpdateColumns

  $schema->NoUpdateColumns(@columns);
  $table ->NoUpdateColumns(@columns);

Defines an array of column names that will be excluded from 
INSERT/UPDATE statements. This is useful for example when
some column are set up automatically by the database 
(like automatic time stamps or user identification).
It can also be useful if you want to temporarily add information
to memory objects, without passing it back to the database.

NoUpdate columns can be set for a whole Schema, or
for a specific Table class.

